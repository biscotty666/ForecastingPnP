---
title: "Chapter 3 Time series decomposition"
output:
  github_document:
    toc: true
  html_document:
    toc: true
    df_print: paged
---

```{r}
library(fpp3)
```

We generally consider three types of patterns in time series:

- trend
- seasonality
- cycles

trend and cycle are usually combined into a single trend-cycle component often just called trend.

A time series can then be decomposed into:

- trend component
- seasonality component of which there may be multiple
- remainder component

# 3.1 Transformations and Adjustments

When decomposing a time series, it is sometimes helpful to first transform or adjust the series in order to make the decomposition (and later analysis) as simple as possible. So we will begin by discussing transformations and adjustments.

## Calendar adjustments

Use average/month rather than raw totals

## Population adjustments

Convert to per capita data where appropriate.

```{r}
global_economy |>
  filter(Country == "Australia") |>
  autoplot(GDP/Population) +
  labs(title = "GDP per capita", y = "$US")
```

## Inflation adjustments

The Consumer Price Index (CPI) can be used to adjust current values for inflation based on a prior time. The price index $z_t$ and the original hose price in year $t$ as $y_t$ can be used to calculated the adjusted value by $x_t=t_t/z_t*z_{2000}$ which would give the adjusted price based on year 2000 dollar values.

As an example, we can look at the annual newspaper and book sales in `aus_retail` and adjust the data for inflation using CPI from `global_economy`


```{r}
print_retail <- aus_retail |>
  filter(Industry == "Newspaper and book retailing") |>
  group_by(Industry) |>
  index_by(Year = year(Month)) |>
  summarise(Turnover = sum(Turnover))
aus_economy <- global_economy |>
  filter(Code == "AUS")
```

```{r}
print_retail |>
  left_join(aus_economy, by = "Year") |>
  mutate(Adjusted_turnover = Turnover / CPI * 100) |>
  pivot_longer(c(Turnover, Adjusted_turnover),
               values_to = "Turnover") |>
  mutate(name = factor(name,
         levels=c("Turnover","Adjusted_turnover"))) |>
  ggplot(aes(x = Year, y = Turnover)) +
  geom_line() +
  facet_grid(name ~ ., scales = "free_y") +
  labs(title = "Turnover: Australian print media industry",
       y = "$AU")
```

By adjusting for inflation we see that the industry is in steeper decline than the raw data suggests.

## Mathematical transformations

**Logarithmic transformations** $w_t=\log({y_t})$, are useful when variation increases and decreases with the level of the series.

**Power transformations** $w_t=y_t^p$ are also used but are more difficult to interpret.

**Box-Cox transformations**

$$
\begin{equation}
  w_t  =
    \begin{cases}
      \log(y_t) & \text{if $\lambda=0$};  \\
      (\text{sign}(y_t)|y_t|^\lambda-1)/\lambda & \text{otherwise}.
    \end{cases}
\end{equation}
$$

In the modified Box-Cox used here negative values of $y_t$ are allowed as long as $\lambda>0$ 

The logarithm used is $ln$.

$\lambda$ should be chosen to make the seasonal variation relatively constant accross the series.

`gerrero` can be used to determine $\lambda$.

```{r}
lambda <- aus_production |>
  features(Gas, features = guerrero) |>
  pull(lambda_guerrero)
lambda
```
```{r}
# install.packages("latex2exp")
aus_production |>
  autoplot(box_cox(Gas, lambda)) +
  labs(y = "",
       title = latex2exp::TeX(paste0(
         "Transformed gas production with $\\lambda$ = ",
         round(lambda,2)
       )))
```

# 3.2 Time series components

- Additive decomposition

Most appropriate if the magnitude of the seasonal fluctuations, or the variation around the trend-cycle, does not vary with the level of the time series.

$$
y_{t} = S_{t} + T_{t} + R_t
$$

where $y_t$ is the data, $S_t$ is the seasonal component, $T_t$ is the trend-cycle component and $R_t$ is the remainder component all at period $t$.

- Multiplicative decomposition

Appropriate whenthe variation in the seasonal pattern, or the variation around the trend-cycle, appears to be proportional to the level of the time series. This is common with economic time series.

$$
y_{t} = S_{t} \times T_{t} \times R_t
$$

Alternatively `log()` can first be used to stabilize the variation over time and then the additive decomposition can be used to calculate the multiplicative decomposition since 

$$
y_{t} = S_{t} \times T_{t} \times R_t \quad\text{is equivalent to}\quad
  \log y_{t} = \log S_{t} + \log T_{t} + \log R_t
$$

## Example: Employment in the US retail sector

```{r}
us_retail_employment <- us_employment |>
  filter(year(Month) >= 1990, Title == "Retail Trade") |>
  select(-Series_ID)
us_retail_employment
```
```{r}
autoplot(us_retail_employment, Employed) +
  labs(y = "Persons (thousands)",
       title = "Total employment in US retail")
```

We can decompose this with the **STL** method discussed later.

```{r}
dcmp <- us_retail_employment |>
  model(stl = STL(Employed))
components(dcmp)
```

This output forms a "dabble" or decomposition table. 

```{r}
components(dcmp) |>
  as_tsibble() |>
  autoplot(Employed, colour = "gray") +
  geom_line(aes(y = trend), colour = "#D55E00") +
  labs(
    y = "Persons (thousands)",
    title = "Total employment in US retail"
  )
```

```{r}
components(dcmp) |> autoplot()
```

The gray bars on the left indicate the relative scale of each graph.

## Seasonally adjusted data

Seasonally adjusted data is what's left after removing the seasonal component from the data, either by subraction or division.

```{r}
components(dcmp) |>
  as_tsibble() |>
  autoplot(Employed, colour = "gray") +
  geom_line(aes(y=season_adjust), colour = "#0072B2") +
  labs(y = "Persons (thousands)",
       title = "Total employment in US retail")
```

Seasonally adjusted data is useful for unemployment data, for example, because it's the non-seasonal aspects which are usually more interesting.

Remember that seasonally adjusted components still contain the trend and remainder.

# 3.3 Moving Averages

Classical decomposition method originating in the 1920s and widely used until the 1950s. It remains the basis of many time series decomposition methods.

The first step is to use a moving average method to estimate the trend-cycle.

## Moving average smoothing

A moving average of order $m$ can be written:

$$
\begin{equation}
  \hat{T}_{t} = \frac{1}{m} \sum_{j=-k}^k y_{t+j}
\end{equation}
$$

where $m=2k+1$. This eliminates some of the randomness and smooths the trend-cycle component. This is called an $m$**-MA**, meaning a moving average of order $m$.

```{r}
global_economy |>
  filter(Country == "Australia") |>
  autoplot(Exports) +
  labs(y = "% of GDP", title = "Total Australian Exports")
```

```{r}
aus_exports <- global_economy |>
  filter(Country == "Australia") |>
  mutate(
    `5-MA` = slider::slide_dbl(Exports, mean,
                .before = 2, .after = 2, .complete = TRUE)
  )
aus_exports
```

```{r}
aus_exports |>
  autoplot(Exports) +
  geom_line(aes(y = `5-MA`), colour = "#D55E00") +
  labs(y = "% of GDP",
       title = "Total Australian exports") +
  guides(colour = guide_legend(title = "series"))
```

The moving average is smoother than the original data. The larger the order the smoother the line.

<img src="https://otexts.com/fpp3/fpp_files/figure-html/aus-exports-compare-1.png" />

Note that the order is usually odd so that the moving objects averages are symmetric.

## Moving averages of moving averages

For even-ordered moving average we can take a moving average of the moving averages to make them symmetrical.

```{r}
beer <- aus_production |>
  filter(year(Quarter) >= 1992) |>
  select(Quarter, Beer)
beer_ma <- beer |>
  mutate(
    `4-MA` = slider::slide_dbl(Beer, mean,
                .before = 1, .after = 2, .complete = TRUE),
    `2x4-MA` = slider::slide_dbl(`4-MA`, mean,
                .before = 1, .after = 0, .complete = TRUE)
  )
beer_ma
```

When a 2-MA follows a moving average of an even order (such as 4), it is called a “centred moving average of order 4”. This is because the results are now symmetric. To see that this is the case, we can write the $2 \times 4$-MA as follows:

$$
\begin{align*}
  \hat{T}_{t} &= \frac{1}{2}\Big[
    \frac{1}{4} (y_{t-2}+y_{t-1}+y_{t}+y_{t+1}) +
    \frac{1}{4} (y_{t-1}+y_{t}+y_{t+1}+y_{t+2})\Big] \\
             &= \frac{1}{8}y_{t-2}+\frac14y_{t-1} +
             \frac14y_{t}+\frac14y_{t+1}+\frac18y_{t+2}.
\end{align*}
$$
Other combinations are commonly used such as $3 \times 3$-MA.

## Estimating the trend-cycle with seasonal data

Centered moving averages are most commonly used for extracting the trend-cycle from seaonal data. For the $2 \times 4$-MA:

$$
\hat{T}_{t} = \frac{1}{8}y_{t-2} + \frac14y_{t-1} +
    \frac14y_{t} + \frac14y_{t+1} + \frac18y_{t+2}
$$

In general a $2 \times m$-MA is equvalent to a weighted moving average of order $m+1$ where all observations take the weight $1/m$ except the first and last which take weights of $1/2m$. For example, a $2 \times 12$-MA can be used to estimate the trend-cycle of monthly data with annual seasonality and a $7$-MA can estimate the trend-cycle of daily data with weekly seasonality.

## Example: Employment in the US retail sector

```{r}
us_retail_employment_ma <- us_retail_employment |>
  mutate(
    `12-MA` = slider::slide_dbl(Employed, mean,
                .before = 5, .after = 6, .complete = TRUE),
    `2x12-MA` = slider::slide_dbl(`12-MA`, mean,
                .before = 1, .after = 0, .complete = TRUE)
  )
us_retail_employment_ma |>
  autoplot(Employed, colour = "gray") +
  geom_line(aes(y = `2x12-MA`), colour = "#D55E00") +
  labs(y = "Persons (thousands)",
       title = "Total employment in US retail")
```

This is much like the trend-cycle obtained earlier with more sophisticated methods.

## Weighted moving averages

$$
\hat{T}_t = \sum_{j=-k}^k a_j y_{t+j}
$$

where $k=(m-1)/2$ and the weights are given by $[a_{-k},\dots,a_k]$ and the **weights must sum to one** and that they are symmetric.







